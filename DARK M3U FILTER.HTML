<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DARK M3U FILTER</title>
    <style>
        :root{
            --bg:#0a1a0a; --panel:#0d1f0d; --muted:#7dd87d; --text:#ffffff;
            --acc:#00ff88; --ok:#00cc66; --danger:#ff3366; --border:#1a3a1a;
            --chip:#0f2a0f; --chip-off:#0a1f0a; --chip-border:#1a3a1a;
            --switch-off:#0a1a0a; --switch-on:#00ff88; --knob:#051505;
        }
        *{box-sizing:border-box}
        body{
            margin:0;
            background:linear-gradient(180deg,#051505,#0a1a0a 40%);
            color:var(--text);
            font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Inter,sans-serif;
            min-height:100vh;
        }
        header{
            position:sticky;top:0;z-index:10;
            background:rgba(10,26,10,.9);
            backdrop-filter:saturate(140%) blur(10px);
            border-bottom:1px solid var(--border);
            padding:15px 0;
        }
        .wrap{max-width:1100px;margin:0 auto;padding:20px}
        h1{margin:0;font-weight:800;letter-spacing:.3px;font-size:clamp(22px,3.6vw,28px)}
        main{padding:24px 0}

        .card{background:var(--panel);border:1px solid var(--border);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.4)}
        .card .body{padding:16px}
        .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
        input[type="text"]{
            flex:1;min-width:260px;background:#0a1a0a;border:1px solid #1a3a1a;
            color:var(--text);padding:12px;border-radius:10px;outline:none;
            font-size:16px;
        }
        .btn{appearance:none;border:1px solid transparent;background:var(--acc);color:#051505;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer}
        .btn.ok{background:var(--ok);color:#051505}
        .btn.danger{background:var(--danger);color:#ffffff}
        .btn.ghost{background:transparent;color:var(--text);border-color:#2a5a2a}
        .hint{font-size:13px;color:var(--muted)}

        /* Tabs ‚Äî 3 responsive columns */
        .tabs{
            display:grid;
            grid-template-columns:repeat(3, minmax(0,1fr));
            gap:10px;
            align-items:stretch;
            margin:8px 0 0;
        }
        .tab{
            min-width:0;
            text-align:center;
            padding:10px 12px;
            border-radius:999px;
            border:1px solid #1a3a1a;
            background:#0a1a0a; color:#b8ffb8;
            cursor:pointer; user-select:none;
            font-size:clamp(13px,3.3vw,16px);
            transition:transform .12s ease, box-shadow .12s ease, background .2s ease;
        }
        .tab:hover{transform:translateY(-1px); box-shadow:0 6px 16px rgba(0,0,0,.25)}
        .tab.active{background:linear-gradient(135deg,#00ff88,#66ff99); color:#051505}
        .tab b{letter-spacing:.2px}
        .tab small{opacity:.85;margin-left:6px}

        /* Toolbar center */
        .toolbar{display:flex;flex-wrap:wrap;gap:10px;margin:12px 0}
        .toolbar.center{justify-content:center;}

        /* Category list area */
        .chips{
            display:flex; flex-direction:column; gap:10px; margin:12px 0 0;
            max-height:50vh; overflow:auto; padding-right:6px; scroll-behavior:smooth;
        }
        .chips::-webkit-scrollbar{width:8px}
        .chips::-webkit-scrollbar-track{background:#0a1a0a;border-radius:8px}
        .chips::-webkit-scrollbar-thumb{background:#1a3a1a;border-radius:8px}
        .chips::-webkit-scrollbar-thumb:hover{background:#2a5a2a}

        .chip{
            display:flex; align-items:center; gap:12px;
            border:1px solid var(--chip-border); background:var(--chip);
            padding:10px 12px; border-radius:999px;
            transition:filter .15s ease, background .15s ease, border-color .15s ease;
        }
        .chip.off{background:var(--chip-off); filter:saturate(.6) brightness(.9); border-color:#1a3a1a}
        .chip .name{flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
        .chip .count{font-size:12px;color:#7dd87d}

        /* ON/OFF Switch */
        .switch{
            position:relative; width:46px; height:26px; border-radius:999px;
            background:var(--switch-off); border:1px solid #1a3a1a; flex:none;
            transition:background .15s ease, border-color .15s ease;
        }
        .switch::after{
            content:""; position:absolute; top:50%; transform:translateY(-50%);
            left:3px; width:20px; height:20px; border-radius:50%;
            background:var(--knob); box-shadow:0 1px 0 rgba(255,255,255,.08), 0 2px 6px rgba(0,0,0,.5);
            transition:left .18s ease;
        }
        .switch.on{background:var(--switch-on); border-color:#00aa55}
        .switch.on::after{left:23px}

        /* Stats and table */
        .statbar{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
        .stat{background:#0a1a0a;border:1px solid #1a3a1a;border-radius:12px;padding:10px}
        .stat b{display:block;font-size:18px}
        .table{border:1px solid #1a3a1a;border-radius:12px;overflow:auto}
        table{width:100%;border-collapse:collapse;font-size:14px}
        th,td{padding:10px;border-bottom:1px solid #0a1a0a}
        th{position:sticky;top:0;background:#051505;text-align:left}

        /* ===== Gradient animated title ===== */
        .title-gradient{
            background:linear-gradient(90deg,#00ff88 0%,#00ccff 45%,#ff00ff 100%);
            background-size:200% 100%;
            -webkit-background-clip:text;
            background-clip:text;
            color:transparent;
            font-weight:900;
            letter-spacing:.3px;
            text-align:center;
            text-shadow:0 0 0 transparent,0 0 24px rgba(0,255,136,.15);
            animation:gradientSlide 8s ease-in-out infinite, wipeFade 5s ease-in-out infinite;
        }
        @keyframes gradientSlide{
            0%{background-position:0% 50%;}
            50%{background-position:100% 50%;}
            100%{background-position:0% 50%;}
        }
        .title-gradient{
            -webkit-mask:linear-gradient(90deg,rgba(0,0,0,1) 0%,rgba(0,0,0,1) 20%,rgba(0,0,0,0) 35%,rgba(0,0,0,0) 65%,rgba(0,0,0,1) 80%,rgba(0,0,0,1) 100%) left/200% 100% no-repeat;
            mask:linear-gradient(90deg,rgba(0,0,0,1) 0%,rgba(0,0,0,1) 20%,rgba(0,0,0,0) 35%,rgba(0,0,0,0) 65%,rgba(0,0,0,1) 80%,rgba(0,0,0,1) 100%) left/200% 100% no-repeat;
        }
        @keyframes wipeFade{
            0%{-webkit-mask-position:left;mask-position:left;}
            50%{-webkit-mask-position:right;mask-position:right;}
            100%{-webkit-mask-position:left;mask-position:left;}
        }
        header h1.title-gradient{font-size:clamp(28px,6.2vw,54px);}

        /* Animated export button */
        .btn.ok {
            background: linear-gradient(90deg, #00cc66, #00ff88, #00ffcc);
            background-size: 300% 100%;
            color: #051505;
            border: none;
            font-weight: 700;
            animation: btnGradient 6s ease-in-out infinite;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .btn.ok:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        }
        @keyframes btnGradient {
            0%{background-position:0% 50%;}
            50%{background-position:100% 50%;}
            100%{background-position:0% 50%;}
        }

        /* === Redesigned stats section === */
        .statwrap{display:flex;gap:16px;align-items:stretch}
        .stat{
            background:#0a1a0a;
            border:1px solid #1a3a1a;
            border-radius:14px;
            padding:12px;
            box-shadow:0 6px 20px rgba(0,0,0,.4), inset 0 1px 0 rgba(255,255,255,.03);
            flex:1;
        }
        .stat.small{padding:8px 10px}
        .stat .label{font-size:13px;opacity:.9;color:#7dd87d;}
        .stat .value{
            display:block;font-size:30px;font-weight:800;margin-top:4px;letter-spacing:.3px;
            color:#ffffff;text-shadow:0 0 12px rgba(0,255,136,.2);
        }

        .vbar{
            width:14px;min-width:14px;border-radius:12px;background:#0a1a0a;border:1px solid #1a3a1a;
            position:relative;overflow:hidden;box-shadow:inset 0 2px 8px rgba(0,0,0,.35);
        }
        .vbar__fill{
            position:absolute;left:0;right:0;bottom:0;height:0%;
            background:linear-gradient(180deg,#00ff88 0%, #00cc66 50%, #00aa44 100%);
            transition:height .35s ease;
        }
        .vbar.is-empty .vbar__fill{
            background:linear-gradient(180deg,#4a7a4a 0%, #2a5a2a 100%);
        }
        .stat-column .stat.small{text-align:center;}
        .statwrap{display:flex;gap:18px;justify-content:space-between;align-items:stretch;}

        /* Media Queries para melhor responsividade */
        @media (max-width:768px){
            .wrap{padding:15px;}
            .toolbar.center{gap:8px;}
            .tabs{grid-template-columns:1fr;}
            .tab{padding:12px 16px;}
            .chips{max-height:40vh;}
            .statwrap{flex-wrap:wrap;}
            .stat{min-width:calc(50% - 9px);}
            .vbar{display:none;}
        }

        @media (max-width:480px){
            .wrap{padding:12px;}
            input[type="text"]{min-width:100%;font-size:14px;padding:10px;}
            .btn{padding:8px 12px;font-size:14px;}
            .card .body{padding:12px;}
            .toolbar.center{gap:6px;}
            .tab{padding:10px 14px;font-size:14px;}
            .stat{min-width:100%;margin-bottom:10px;}
            .stat .value{font-size:24px;}
            .chips{max-height:35vh;}
        }

        @media (max-width:360px){
            .wrap{padding:10px;}
            .tab{padding:8px 12px;}
            .btn{padding:6px 10px;font-size:13px;}
            .card .body{padding:10px;}
        }
    </style>
</head>
<body>
    <header>
        <div class="wrap">
            <h1 class="title-gradient">DARK M3U FILTER</h1>
        </div>
    </header>

    <main class="wrap">
        <div class="card">
            <div class="body">
                <div class="row">
                    <input type="text" id="m3uUrl" placeholder="Cole a URL da sua lista M3U ou Xtream...">
                    <button class="btn" id="btnFetch">Carregar</button>
                </div>
                <div class="hint" id="status">Insira a URL da sua lista M3U ou Xtream para come√ßar</div>
                <div class="hint" id="domainInfo"></div>
            </div>
        </div>

        <div class="card" style="margin-top:20px">
            <div class="body">
                <div class="tabs">
                    <div class="tab active" data-type="live"><b>Canais</b> <small id="count-live">0</small></div>
                    <div class="tab" data-type="vod"><b>Filmes</b> <small id="count-vod">0</small></div>
                    <div class="tab" data-type="series"><b>S√©ries</b> <small id="count-series">0</small></div>
                </div>

                <div class="toolbar center">
                    <button class="btn ghost" id="btnAll">Marcar Todos</button>
                    <button class="btn ghost" id="btnNone">Desmarcar Todos</button>
                </div>

                <div class="chips" id="chips"></div>

                <div class="statwrap">
                    <div class="stat">
                        <div class="label">Categorias</div>
                        <div class="value" id="statCats">0</div>
                    </div>
                    <div class="stat">
                        <div class="label">Total</div>
                        <div class="value" id="statTotal">0</div>
                    </div>
                    <div class="stat">
                        <div class="label">Filtrados</div>
                        <div class="value" id="statAfter">0</div>
                    </div>
                    <div class="vbar" id="keepBar">
                        <div class="vbar__fill" id="keepFill"></div>
                    </div>
                </div>

                <div class="toolbar center">
                    <button class="btn ok" id="btnExport">Exportar Lista</button>
                    <button class="btn" id="btnPreview">Visualizar</button>
                </div>
                <div class="hint" id="exportHint"></div>

                <div class="table" id="previewBox" style="display:none;margin-top:20px">
                    <table>
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Info</th>
                                <th>URL</th>
                            </tr>
                        </thead>
                        <tbody id="previewT"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </main>

    <footer style="
        text-align:center;
        padding:20px 0 26px;
        font-size:13px;
        color:#7dd87d;
        opacity:0.8;
        letter-spacing:0.5px;
      ">
        <span style="font-weight:600;">DARK MENSAGEIRO</span>
    </footer>

    <script>
    (function(){
      "use strict";

      /* Forced proxy (hidden in UI) */
      const PROXY = "https://vegetatv1.vegetatvoficial.workers.dev/?url=";
      const through = (url) => PROXY + encodeURIComponent(url);

      /* State */
      const el = (id)=>document.getElementById(id);
      const status = el("status");
      let activeType = "live";                 // 'live' | 'vod' | 'series'
      const selected = {live:new Set(), vod:new Set(), series:new Set()};
      const cats     = {live:[], vod:[], series:[]};       // [{id,name,count}]
      const streams  = {live:[], vod:[], series:[]};       // items
      const seriesEpisodes = {}; // Cache para epis√≥dios de s√©ries
      let mode = "m3u";                                   // 'm3u' or 'xtream'
      let xtream = null;

      function setStatus(msg){ status.textContent = msg || ""; }
      function extractDomainFromUrl(url){
        try{ return new URL(url.trim()).hostname.replace(/^www\./,''); } catch{ return ""; }
      }
      function setDetectedDomain(domain){
        const info = el('domainInfo');
        const hint = el('exportHint');
        if(domain){ info.textContent = "üåê Detected domain: " + domain; hint.dataset.domain = domain; }
        else { info.textContent = ""; delete hint.dataset.domain; }
      }

      /* Tabs */
      document.querySelectorAll('.tab').forEach(t=>{
        t.addEventListener('click', ()=>{
          document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
          t.classList.add('active');
          activeType = t.dataset.type;
          renderChips();
          refreshStats();
        });
      });

      /* Utils */
      function escapeHtml(s){
        const map = {"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"};
        return String(s).replace(/[&<>"]/g, c => map[c]);
      }
      function groupBy(arr, key){ const m=new Map(); for(const it of arr){ const k=it[key]; m.set(k,(m.get(k)||0)+1); } return m; }
      function titleEscape(s){ return String(s).replace(/"/g,'\\"'); }

      /* M3U parser */
      function parseM3U(text){
        const lines = String(text||"").replace(/\r/g,"").split(/\n/);
        const items = [];
        for(let i=0;i<lines.length;i++){
          const line = (lines[i]||"").trim(); if(!line) continue;
          if(line.startsWith("#EXTINF")){
            const ext = line; let url=""; let j=i+1;
            while(j<lines.length && !(url=(lines[j]||"").trim())) j++;
            let group = "Other"; const m = ext.match(/group-title\s*=\s*"([^"]*)"/i); if(m) group = m[1];
            items.push({ext,url,group}); i=j;
          }
        }
        return items;
      }

      function loadM3U(text){
        mode = "m3u";
        const items = parseM3U(text);
        streams.live = items; streams.vod = []; streams.series = [];
        const map = groupBy(items,"group");
        cats.live = [...map.entries()]
          .sort((a,b)=>a[0].localeCompare(b[0],'en',{sensitivity:'base'}))
          .map(([name,count])=>({id:name,name,count}));
        selected.live = new Set(cats.live.map(c=>c.id));
        cats.vod=[]; cats.series=[]; selected.vod.clear(); selected.series.clear();
        activeType="live"; document.querySelector('[data-type="live"]').click();
        el('count-live').textContent = String(items.length);
        el('count-vod').textContent = "0"; el('count-series').textContent = "0";
        setStatus("OK ‚Äî M3U loaded.");
      }

      /* Xtream */
      function parseXtreamFromGet(url){
        try {
          const u = new URL(url);

          const host = u.hostname;
          const rawPort = u.port;                 // ex: "8080" ou ""
          const port = rawPort ? `:${rawPort}` : "";

          const q = new URLSearchParams(u.search);
          const user = q.get("username");
          const pass = q.get("password");
          if (!user || !pass) return null;

          // ‚úÖ Conserver le protocole exact d'entr√©e ("http:" ou "https:")
          const proto = u.protocol;

          // ‚úÖ Stocker aussi le protocole original pour l'export (m√™me si la page est HTTPS)
          const originalProto = proto;

          // Base API qui respecte le protocole d'origine
          const base = `${proto}//${host}${port}/player_api.php?username=${encodeURIComponent(user)}&password=${encodeURIComponent(pass)}`;

          return {
            base,              // ex: http://host:port/player_api.php?username=...&password=...
            host,              // ex: "vipketseyket.top"
            port: rawPort,     // ex: "8080" (sans le ':')
            u: user,
            p: pass,
            domain: host,      // alias pratique
            proto,             // ex: "http:" ou "https:"
            originalProto      // ‚ö° √† utiliser dans export pour respecter ton lien d‚Äôorigine
          };
        } catch (e) {
          return null;
        }
      }
      async function fetchJson(url){ const r = await fetch(through(url), {cache:"no-store"}); if(!r.ok) throw new Error("HTTP "+r.status); return r.json(); }

      // Fun√ß√£o para carregar epis√≥dios de uma s√©rie
      async function loadSeriesEpisodes(seriesId) {
        if (seriesEpisodes[seriesId]) {
          return seriesEpisodes[seriesId];
        }
        
        try {
          const url = `${xtream.base}&action=get_series_info&series_id=${seriesId}`;
          const data = await fetchJson(url);
          
          const episodes = [];
          if (data.episodes) {
            for (const seasonKey in data.episodes) {
              const seasonNum = seasonKey.replace('season', '');
              const seasonEpisodes = data.episodes[seasonKey];
              for (const ep of seasonEpisodes) {
                episodes.push({
                  series_id: seriesId,
                  season: seasonNum,
                  episode: ep.episode_num,
                  title: ep.title,
                  id: ep.id,
                  container_extension: ep.container_extension || 'mp4'
                });
              }
            }
          }
          
          seriesEpisodes[seriesId] = episodes;
          return episodes;
        } catch (e) {
          console.error(`Failed to load episodes for series ${seriesId}:`, e);
          return [];
        }
      }

      async function loadXtream(getUrl){
        mode="xtream"; xtream = parseXtreamFromGet(getUrl); if(!xtream) throw new Error("Invalid Xtream URL (missing username/password).");
        const [liveCats, vodCats, seriesCats] = await Promise.all([
          fetchJson(`${xtream.base}&action=get_live_categories`),
          fetchJson(`${xtream.base}&action=get_vod_categories`),
          fetchJson(`${xtream.base}&action=get_series_categories`)
        ]);
        const [liveStreams, vodStreams, seriesItems] = await Promise.all([
          fetchJson(`${xtream.base}&action=get_live_streams`),
          fetchJson(`${xtream.base}&action=get_vod_streams`),
          fetchJson(`${xtream.base}&action=get_series`)
        ]);

        const liveCounts = groupBy(liveStreams,"category_id");
        cats.live = liveCats.map(c=>({id:c.category_id,name:c.category_name,count:liveCounts.get(c.category_id)||0}))
                            .sort((a,b)=>a.name.localeCompare(b.name,'en',{sensitivity:'base'}));
        streams.live = liveStreams; selected.live = new Set(cats.live.map(c=>c.id)); el('count-live').textContent=String(liveStreams.length);

        const vodCounts = groupBy(vodStreams,"category_id");
        cats.vod = vodCats.map(c=>({id:c.category_id,name:c.category_name,count:vodCounts.get(c.category_id)||0}))
                          .sort((a,b)=>a.name.localeCompare(b.name,'en',{sensitivity:'base'}));
        streams.vod = vodStreams; selected.vod = new Set(cats.vod.map(c=>c.id)); el('count-vod').textContent=String(vodStreams.length);

        // Para s√©ries, contamos o n√∫mero de s√©ries, n√£o epis√≥dios
        const serCounts = groupBy(seriesItems,"category_id");
        cats.series = seriesCats.map(c=>({id:c.category_id,name:c.category_name,count:serCounts.get(c.category_id)||0}))
                                .sort((a,b)=>a.name.localeCompare(b.name,'en',{sensitivity:'base'}));
        streams.series = seriesItems; selected.series = new Set(cats.series.map(c=>c.id)); el('count-series').textContent=String(seriesItems.length);

        // Limpar cache de epis√≥dios
        for (const key in seriesEpisodes) {
          delete seriesEpisodes[key];
        }

        activeType="live"; document.querySelector('[data-type="live"]').click();
        setStatus("OK ‚Äî Xtream (TV/VOD/Series categories) loaded.");
      }

      /* Render categories + switches */
      function renderChips(){
        const wrap = el("chips"); wrap.innerHTML = "";
        const list = cats[activeType] || []; el('statCats').textContent = list.length;
        const currentSelected = selected[activeType];

        for(const c of list){
          const chip = document.createElement("label");
          chip.className = "chip";
          if(!currentSelected.has(c.id)) chip.classList.add("off");

          const sw = document.createElement("span");
          sw.className = "switch" + (currentSelected.has(c.id) ? " on" : "");
          const name = document.createElement("span"); name.className="name"; name.textContent = c.name;
          const cnt  = document.createElement("span"); cnt.className="count"; cnt.textContent = c.count;

          const toggle = () => {
            if(currentSelected.has(c.id)){ currentSelected.delete(c.id); sw.classList.remove("on"); chip.classList.add("off"); }
            else { currentSelected.add(c.id); sw.classList.add("on"); chip.classList.remove("off"); }
            refreshStats();
          };
          sw.addEventListener("click", (e)=>{ e.preventDefault(); toggle(); });
          chip.addEventListener("click", (e)=>{ if(e.target===chip || e.target===name || e.target===cnt){ toggle(); } });

          chip.append(sw, name, cnt); wrap.append(chip);
        }
      }

      /* Stats */
      async function refreshStats(){
        let total=0, kept=0;

        if(mode==="m3u" && activeType==="live"){
          total = streams.live.length;
          const keep = selected.live; const keepAll = keep.size===0;
          for(const it of streams.live){ if(keepAll || keep.has(it.group)) kept++; }
        } else if (mode === "xtream" && activeType === "series") {
          // Para s√©ries, precisamos contar os epis√≥dios
          total = 0;
          kept = 0;
          const keep = selected.series;
          const keepAll = keep.size === 0;
          
          for (const series of streams.series) {
            if (keepAll || keep.has(series.category_id)) {
              const episodes = await loadSeriesEpisodes(series.series_id);
              total += episodes.length;
              kept += episodes.length;
            }
          }
        } else {
          const arr = streams[activeType] || [];
          const keep = selected[activeType]; const keepAll = keep.size===0;
          total = arr.length;
          for(const s of arr){ if(keepAll || keep.has(s.category_id)) kept++; }
        }

        el("statTotal").textContent = total;
        el("statAfter").textContent = kept;
        updateKeepBar(total, kept);
      }

      function updateKeepBar(total, kept){
        const fill = document.getElementById("keepFill");
        const bar  = document.getElementById("keepBar");
        if(!fill || !bar) return;

        if(total <= 0){
          bar.classList.add("is-empty");
          fill.style.height = "0%";
          fill.title = "0% kept";
          return;
        }
        bar.classList.remove("is-empty");
        const pct = Math.max(0, Math.min(100, Math.round((kept/total)*100)));
        fill.style.height = pct + "%";
        fill.title = pct + "% kept";
      }

      /* Export */
      function filenameBase(){ return (el("exportHint").dataset.domain || "filtered").replace(/[^a-z0-9.-]/gi,"_"); }

      function exportM3U_live_xtream(){
        const baseHost = (xtream.originalProto || xtream.proto) + "//" + xtream.host + (xtream.port ? (":" + xtream.port) : "");
        const keep = selected.live; const keepAll = keep.size===0; const parts=["#EXTM3U"];
        for(const s of streams.live){
          if(keepAll || keep.has(s.category_id)){
            const catName = (cats.live.find(c=>c.id==s.category_id)||{}).name || "TV";
            const title = s.name || s.stream_display_name || ("Live " + s.stream_id);
            const ext = `#EXTINF:-1 tvg-id="" group-title="${titleEscape(catName)}", ${titleEscape(title)}`;
            const url = `${baseHost}/live/${encodeURIComponent(xtream.u)}/${encodeURIComponent(xtream.p)}/${s.stream_id}.m3u8`;
            parts.push(ext,url);
          }
        }
        return parts.join("\n")+"\n";
      }

      function exportM3U_vod_xtream(){
        // Respecte le protocole d'entr√©e (HTTP reste HTTP)
        const baseHost = xtream.proto + "//" + xtream.host + (xtream.port ? (":" + xtream.port) : "");

        const keep = selected.vod;
        const keepAll = keep.size === 0;
        const parts = ["#EXTM3U"];

        for (const s of streams.vod){
          if (keepAll || keep.has(s.category_id)){
            const catName = (cats.vod.find(c => c.id == s.category_id) || {}).name || "VOD";
            const title = s.name || s.stream_display_name || ("VOD " + s.stream_id);
            const extn = s.container_extension || "mp4";
            const ext  = `#EXTINF:-1 tvg-id="" group-title="${titleEscape(catName)}", ${titleEscape(title)}`;
            const url  = `${baseHost}/movie/${encodeURIComponent(xtream.u)}/${encodeURIComponent(xtream.p)}/${s.stream_id}.${extn}`;
            parts.push(ext, url);
          }
        }
        return parts.join("\n") + "\n";
      }

      async function exportM3U_series_xtream(){
        const baseHost = xtream.proto + "//" + xtream.host + (xtream.port ? ":" + xtream.port : "");
        const keep = selected.series;
        const keepAll = keep.size === 0;
        const parts = ["#EXTM3U"];

        for (const series of streams.series) {
          if (keepAll || keep.has(series.category_id)) {
            const categoryName = (cats.series.find(c => c.id === series.category_id) || {}).name || "Series";
            const episodes = await loadSeriesEpisodes(series.series_id);
            
            for (const ep of episodes) {
              const title = `${series.name} S${ep.season}E${ep.episode} - ${ep.title}`;
              const ext = `#EXTINF:-1 tvg-id="" group-title="${titleEscape(categoryName)}", ${titleEscape(title)}`;
              const url = `${baseHost}/series/${encodeURIComponent(xtream.u)}/${encodeURIComponent(xtream.p)}/${ep.id}.${ep.container_extension}`;
              parts.push(ext, url);
            }
          }
        }
        return parts.join("\n") + "\n";
      }

      function exportM3U_m3u_simple(){
        const keep = selected.live; const keepAll = keep.size===0; const parts=["#EXTM3U"];
        for(const it of streams.live){ if(keepAll || keep.has(it.group)){ parts.push(it.ext,it.url); } }
        return parts.join("\n")+"\n";
      }

      async function doExport(){
        let data="";
        if(mode==="xtream"){
          if(activeType==="live") data = exportM3U_live_xtream();
          else if(activeType==="vod") data = exportM3U_vod_xtream();
          else if(activeType==="series") data = await exportM3U_series_xtream();
          else { alert("Invalid type."); return; }
        }else{
          if(activeType!=="live"){ alert("This M3U contains only channels (TV tab)."); return; }
          data = exportM3U_m3u_simple();
        }
        const blob = new Blob([data], {type:"application/octet-stream"});
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = `${filenameBase()}_${activeType}_filtered.m3u`;
        a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),12000);
        el("exportHint").textContent = "Generated file: " + a.download;
      }

      /* Preview 200 lines */
      async function showPreview(){
        let rows = [];
        let idx = 0;
        const add = (ext, url) =>
          rows.push(
            `<tr><td>${++idx}</td><td>${escapeHtml(ext)}</td><td>${escapeHtml(url)}</td></tr>`
          );

        if (mode === "xtream") {
          // ‚úÖ Respecte le protocole d'origine (http ou https)
          const baseHost = xtream.proto + "//" + xtream.host + (xtream.port ? (":" + xtream.port) : "");

          if (activeType === "live") {
            const keep = selected.live;
            const keepAll = keep.size === 0;

            for (const s of streams.live) {
              if (keepAll || keep.has(s.category_id)) {
                const cat = (cats.live.find(c => c.id == s.category_id) || {}).name || "TV";
                const t = s.name || s.stream_display_name || ("Live " + s.stream_id);
                add(
                  `#EXTINF:-1 tvg-id="" group-title="${titleEscape(cat)}", ${titleEscape(t)}`,
                  `${baseHost}/live/${encodeURIComponent(xtream.u)}/${encodeURIComponent(xtream.p)}/${s.stream_id}.m3u8`
                );
                if (idx >= 200) break;
              }
            }

          } else if (activeType === "vod") {
            const keep = selected.vod;
            const keepAll = keep.size === 0;

            for (const s of streams.vod) {
              if (keepAll || keep.has(s.category_id)) {
                const cat = (cats.vod.find(c => c.id == s.category_id) || {}).name || "VOD";
                const t = s.name || s.stream_display_name || ("VOD " + s.stream_id);
                const extn = s.container_extension || "mp4";
                add(
                  `#EXTINF:-1 tvg-id="" group-title="${titleEscape(cat)}", ${titleEscape(t)}`,
                  `${baseHost}/movie/${encodeURIComponent(xtream.u)}/${encodeURIComponent(xtream.p)}/${s.stream_id}.${extn}`
                );
                if (idx >= 200) break;
              }
            }

          } else if (activeType === "series") {
            const keep = selected.series;
            const keepAll = keep.size === 0;

            for (const series of streams.series) {
              if (keepAll || keep.has(series.category_id)) {
                const categoryName = (cats.series.find(c => c.id === series.category_id) || {}).name || "Series";
                const episodes = await loadSeriesEpisodes(series.series_id);
                
                for (const ep of episodes) {
                  const title = `${series.name} S${ep.season}E${ep.episode} - ${ep.title}`;
                  const ext = `#EXTINF:-1 tvg-id="" group-title="${titleEscape(categoryName)}", ${titleEscape(title)}`;
                  const url = `${baseHost}/series/${encodeURIComponent(xtream.u)}/${encodeURIComponent(xtream.p)}/${ep.id}.${ep.container_extension}`;
                  add(ext, url);
                  if (idx >= 200) break;
                }
                if (idx >= 200) break;
              }
            }
          }

        } else {
          const keep = selected.live;
          const keepAll = keep.size === 0;
          for (const it of streams.live) {
            if (keepAll || keep.has(it.group)) {
              add(it.ext, it.url);
              if (idx >= 200) break;
            }
          }
        }

        document.getElementById("previewT").innerHTML = rows.join("");
        document.getElementById("previewBox").style.display = "block";
      }
      /* Load URL */
      async function loadFromUrl(){
        const url = el("m3uUrl").value.trim(); if(!url){ setStatus("Enter a URL."); return; }
        setDetectedDomain(extractDomainFromUrl(url)); setStatus("Loading‚Ä¶");
        try{
          if(/\/get\.php/i.test(url)){ await loadXtream(url); }
          else{
            const res = await fetch(through(url), {cache:"no-store"}); if(!res.ok) throw new Error("HTTP "+res.status);
            const text = await res.text(); loadM3U(text);
          }
        }catch(e){ console.error(e); setStatus("Failed: "+e.message); alert("Load failed: "+e.message); }
      }

      /* UI bindings */
      el("btnFetch").onclick = loadFromUrl;
      el("btnExport").onclick = doExport;
      el("btnPreview").onclick = showPreview;
      el("btnAll").onclick  = async ()=>{ 
        const s=selected[activeType]; 
        s.clear(); 
        for(const c of cats[activeType]) s.add(c.id); 
        renderChips(); 
        await refreshStats(); 
      };
      el("btnNone").onclick = async ()=>{ 
        selected[activeType].clear(); 
        renderChips(); 
        await refreshStats(); 
      };
    })();
    </script>
</body>
</html>